"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/api-client.ts":
/*!*******************************!*\
  !*** ./src/lib/api-client.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebApiClient: function() { return /* binding */ WebApiClient; }\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"(app-pages-browser)/./src/lib/config.ts\");\n\nfunction inferMimeType(file) {\n    if (file.type && [\n        \"image/png\",\n        \"image/jpeg\",\n        \"image/webp\",\n        \"application/pdf\"\n    ].includes(file.type)) {\n        return file.type;\n    }\n    const normalized = file.name.toLowerCase();\n    if (normalized.endsWith(\".png\")) return \"image/png\";\n    if (normalized.endsWith(\".jpg\") || normalized.endsWith(\".jpeg\")) return \"image/jpeg\";\n    if (normalized.endsWith(\".webp\")) return \"image/webp\";\n    if (normalized.endsWith(\".pdf\")) return \"application/pdf\";\n    throw new Error(\"Unsupported file type. Use png, jpg, webp, or pdf.\");\n}\nclass WebApiClient {\n    createUrl(path, query) {\n        const base = _config__WEBPACK_IMPORTED_MODULE_0__.apiBaseUrl.endsWith(\"/\") ? _config__WEBPACK_IMPORTED_MODULE_0__.apiBaseUrl : \"\".concat(_config__WEBPACK_IMPORTED_MODULE_0__.apiBaseUrl, \"/\");\n        const resolvedBase = base.startsWith(\"http://\") || base.startsWith(\"https://\") ? base : \"\".concat(window.location.origin).concat(base.startsWith(\"/\") ? \"\" : \"/\").concat(base);\n        const url = new URL(path.replace(/^\\//, \"\"), resolvedBase);\n        if (query) {\n            for (const [key, value] of Object.entries(query)){\n                if (value !== undefined && value !== \"\") {\n                    url.searchParams.set(key, String(value));\n                }\n            }\n        }\n        return url.toString();\n    }\n    async requestEnvelope(method, path) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const headers = {\n            Accept: \"application/json\"\n        };\n        let body;\n        if (options.body !== undefined) {\n            headers[\"Content-Type\"] = \"application/json\";\n            body = JSON.stringify(options.body);\n        }\n        // Cookies are sent automatically; the proxy injects the Bearer token\n        const response = await fetch(this.createUrl(path, options.query), {\n            method,\n            headers,\n            body,\n            credentials: \"same-origin\"\n        });\n        const json = await response.json().catch(()=>({}));\n        if (!response.ok || json.success === false) {\n            var _json_error;\n            var _json_error_message;\n            const message = (_json_error_message = (_json_error = json.error) === null || _json_error === void 0 ? void 0 : _json_error.message) !== null && _json_error_message !== void 0 ? _json_error_message : \"\".concat(response.status, \" \").concat(response.statusText);\n            throw new Error(message);\n        }\n        return json;\n    }\n    async requestData(method, path) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const response = await this.requestEnvelope(method, path, options);\n        if (response.data === undefined) throw new Error(\"API returned no data\");\n        return response.data;\n    }\n    async uploadFile(file) {\n        const mimeType = inferMimeType(file);\n        const init = await this.requestData(\"POST\", \"/assets/upload\", {\n            body: {\n                fileName: file.name,\n                mimeType,\n                fileSize: file.size\n            }\n        });\n        const uploadResponse = await fetch(init.sasUploadUrl, {\n            method: \"PUT\",\n            headers: {\n                \"x-ms-blob-type\": \"BlockBlob\",\n                \"Content-Type\": mimeType\n            },\n            body: file\n        });\n        if (!uploadResponse.ok) {\n            throw new Error(\"Blob upload failed: \".concat(uploadResponse.status, \" \").concat(uploadResponse.statusText));\n        }\n        return this.requestData(\"POST\", \"/assets/upload/confirm\", {\n            body: {\n                assetId: init.assetId\n            }\n        });\n    }\n    async listAssets(params) {\n        var _response_pagination;\n        const response = await this.requestEnvelope(\"GET\", \"/assets\", {\n            query: params\n        });\n        var _response_data;\n        return {\n            items: (_response_data = response.data) !== null && _response_data !== void 0 ? _response_data : [],\n            continuationToken: (_response_pagination = response.pagination) === null || _response_pagination === void 0 ? void 0 : _response_pagination.continuationToken\n        };\n    }\n    async getAsset(id) {\n        return this.requestData(\"GET\", \"/assets/\".concat(id));\n    }\n    async getAssetViewUrl(id) {\n        const response = await this.requestData(\"GET\", \"/assets/\".concat(id, \"/view-url\"));\n        if (!response.viewUrl) {\n            throw new Error(\"View URL unavailable\");\n        }\n        return response.viewUrl;\n    }\n    async deleteAsset(id) {\n        await this.requestEnvelope(\"DELETE\", \"/assets/\".concat(id));\n    }\n    async listCategories() {\n        return this.requestData(\"GET\", \"/categories\");\n    }\n    async createCategory(name) {\n        return this.requestData(\"POST\", \"/categories\", {\n            body: {\n                name,\n                fieldPriorities: []\n            }\n        });\n    }\n    async updateCategory(id, payload) {\n        return this.requestData(\"PATCH\", \"/categories/\".concat(id), {\n            body: payload\n        });\n    }\n    async deleteCategory(id) {\n        await this.requestEnvelope(\"DELETE\", \"/categories/\".concat(id));\n    }\n    async search(query) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20;\n        return this.requestData(\"GET\", \"/search\", {\n            query: {\n                q: query,\n                limit\n            }\n        });\n    }\n    async getSettings() {\n        return this.requestData(\"GET\", \"/settings\");\n    }\n    async updateSettings(payload) {\n        return this.requestData(\"PATCH\", \"/settings\", {\n            body: payload\n        });\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXBpLWNsaWVudC50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUNzQztBQW1CdEMsU0FBU0MsY0FBY0MsSUFBVTtJQUMvQixJQUFJQSxLQUFLQyxJQUFJLElBQUk7UUFBQztRQUFhO1FBQWM7UUFBYztLQUFrQixDQUFDQyxRQUFRLENBQUNGLEtBQUtDLElBQUksR0FBRztRQUNqRyxPQUFPRCxLQUFLQyxJQUFJO0lBQ2xCO0lBRUEsTUFBTUUsYUFBYUgsS0FBS0ksSUFBSSxDQUFDQyxXQUFXO0lBQ3hDLElBQUlGLFdBQVdHLFFBQVEsQ0FBQyxTQUFTLE9BQU87SUFDeEMsSUFBSUgsV0FBV0csUUFBUSxDQUFDLFdBQVdILFdBQVdHLFFBQVEsQ0FBQyxVQUFVLE9BQU87SUFDeEUsSUFBSUgsV0FBV0csUUFBUSxDQUFDLFVBQVUsT0FBTztJQUN6QyxJQUFJSCxXQUFXRyxRQUFRLENBQUMsU0FBUyxPQUFPO0lBQ3hDLE1BQU0sSUFBSUMsTUFBTTtBQUNsQjtBQUVPLE1BQU1DO0lBQ0hDLFVBQVVDLElBQVksRUFBRUMsS0FBbUQsRUFBVTtRQUMzRixNQUFNQyxPQUFPZCwrQ0FBVUEsQ0FBQ1EsUUFBUSxDQUFDLE9BQU9SLCtDQUFVQSxHQUFHLEdBQWMsT0FBWEEsK0NBQVVBLEVBQUM7UUFDbkUsTUFBTWUsZUFDSkQsS0FBS0UsVUFBVSxDQUFDLGNBQWNGLEtBQUtFLFVBQVUsQ0FBQyxjQUMxQ0YsT0FDQSxHQUE0QkEsT0FBekJHLE9BQU9DLFFBQVEsQ0FBQ0MsTUFBTSxFQUFxQ0wsT0FBbENBLEtBQUtFLFVBQVUsQ0FBQyxPQUFPLEtBQUssS0FBVyxPQUFMRjtRQUNwRSxNQUFNTSxNQUFNLElBQUlDLElBQUlULEtBQUtVLE9BQU8sQ0FBQyxPQUFPLEtBQUtQO1FBQzdDLElBQUlGLE9BQU87WUFDVCxLQUFLLE1BQU0sQ0FBQ1UsS0FBS0MsTUFBTSxJQUFJQyxPQUFPQyxPQUFPLENBQUNiLE9BQVE7Z0JBQ2hELElBQUlXLFVB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Y0FBcUM7UUFDekMsT0FBTyxJQUFJLENBQUM5QixXQUFXLENBQWUsT0FBTztJQUMvQztJQUVBLE1BQU0rQixlQUFlTixPQUEyRyxFQUF5QjtRQUN2SixPQUFPLElBQUksQ0FBQ3pCLFdBQVcsQ0FBZSxTQUFTLGFBQWE7WUFBRWQsTUFBTXVDO1FBQVE7SUFDOUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2FwaS1jbGllbnQudHM/YWMxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEFzc2V0LCBDYXRlZ29yeSwgVXNlclNldHRpbmdzIH0gZnJvbSBcIkBzY2FudmF1bHQvc2hhcmVkXCI7XG5pbXBvcnQgeyBhcGlCYXNlVXJsIH0gZnJvbSBcIi4vY29uZmlnXCI7XG5cbmludGVyZmFjZSBBcGlFbnZlbG9wZTxUPiB7XG4gIHN1Y2Nlc3M6IGJvb2xlYW47XG4gIGRhdGE/OiBUO1xuICBlcnJvcj86IHsgY29kZTogc3RyaW5nOyBtZXNzYWdlOiBzdHJpbmcgfTtcbiAgcGFnaW5hdGlvbj86IHsgY29udGludWF0aW9uVG9rZW4/OiBzdHJpbmcgfTtcbn1cblxuaW50ZXJmYWNlIFVwbG9hZEluaXRSZXNwb25zZSB7XG4gIGFzc2V0SWQ6IHN0cmluZztcbiAgc2FzVXBsb2FkVXJsOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBTZWFyY2hSZXNwb25zZSB7XG4gIHF1ZXJ5OiB1bmtub3duO1xuICBpdGVtczogQXNzZXRbXTtcbn1cblxuZnVuY3Rpb24gaW5mZXJNaW1lVHlwZShmaWxlOiBGaWxlKTogc3RyaW5nIHtcbiAgaWYgKGZpbGUudHlwZSAmJiBbXCJpbWFnZS9wbmdcIiwgXCJpbWFnZS9qcGVnXCIsIFwiaW1hZ2Uvd2VicFwiLCBcImFwcGxpY2F0aW9uL3BkZlwiXS5pbmNsdWRlcyhmaWxlLnR5cGUpKSB7XG4gICAgcmV0dXJuIGZpbGUudHlwZTtcbiAgfVxuXG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBmaWxlLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKG5vcm1hbGl6ZWQuZW5kc1dpdGgoXCIucG5nXCIpKSByZXR1cm4gXCJpbWFnZS9wbmdcIjtcbiAgaWYgKG5vcm1hbGl6ZWQuZW5kc1dpdGgoXCIuanBnXCIpIHx8IG5vcm1hbGl6ZWQuZW5kc1dpdGgoXCIuanBlZ1wiKSkgcmV0dXJuIFwiaW1hZ2UvanBlZ1wiO1xuICBpZiAobm9ybWFsaXplZC5lbmRzV2l0aChcIi53ZWJwXCIpKSByZXR1cm4gXCJpbWFnZS93ZWJwXCI7XG4gIGlmIChub3JtYWxpemVkLmVuZHNXaXRoKFwiLnBkZlwiKSkgcmV0dXJuIFwiYXBwbGljYXRpb24vcGRmXCI7XG4gIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGZpbGUgdHlwZS4gVXNlIHBuZywganBnLCB3ZWJwLCBvciBwZGYuXCIpO1xufVxuXG5leHBvcnQgY2xhc3MgV2ViQXBpQ2xpZW50IHtcbiAgcHJpdmF0ZSBjcmVhdGVVcmwocGF0aDogc3RyaW5nLCBxdWVyeT86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IHVuZGVmaW5lZD4pOiBzdHJpbmcge1xuICAgIGNvbnN0IGJhc2UgPSBhcGlCYXNlVXJsLmVuZHNXaXRoKFwiL1wiKSA/IGFwaUJhc2VVcmwgOiBgJHthcGlCYXNlVXJsfS9gO1xuICAgIGNvbnN0IHJlc29sdmVkQmFzZSA9XG4gICAgICBiYXNlLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpIHx8IGJhc2Uuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpXG4gICAgICAgID8gYmFzZVxuICAgICAgICA6IGAke3dpbmRvdy5sb2NhdGlvbi5vcmlnaW59JHtiYXNlLnN0YXJ0c1dpdGgoXCIvXCIpID8gXCJcIiA6IFwiL1wifSR7YmFzZX1gO1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocGF0aC5yZXBsYWNlKC9eXFwvLywgXCJcIiksIHJlc29sdmVkQmFzZSk7XG4gICAgaWYgKHF1ZXJ5KSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhxdWVyeSkpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IFwiXCIpIHtcbiAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmVxdWVzdEVudmVsb3BlPFQ+KFxuICAgIG1ldGhvZDogc3RyaW5nLFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zOiB7IGJvZHk/OiB1bmtub3duOyBxdWVyeT86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IHVuZGVmaW5lZD4gfSA9IHt9XG4gICk6IFByb21pc2U8QXBpRW52ZWxvcGU8VD4+IHtcbiAgICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0geyBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiIH07XG5cbiAgICBsZXQgYm9keTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGlmIChvcHRpb25zLmJvZHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYm9keSk7XG4gICAgfVxuXG4gICAgLy8gQ29va2llcyBhcmUgc2VudCBhdXRvbWF0aWNhbGx5OyB0aGUgcHJveHkgaW5qZWN0cyB0aGUgQmVhcmVyIHRva2VuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLmNyZWF0ZVVybChwYXRoLCBvcHRpb25zLnF1ZXJ5KSwge1xuICAgICAgbWV0aG9kLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHksXG4gICAgICBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiLFxuICAgIH0pO1xuXG4gICAgY29uc3QganNvbiA9IChhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSkpIGFzIEFwaUVudmVsb3BlPFQ+O1xuXG4gICAgaWYgKCFyZXNwb25zZS5vayB8fCBqc29uLnN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0ganNvbi5lcnJvcj8ubWVzc2FnZSA/PyBgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyByZXF1ZXN0RGF0YTxUPihcbiAgICBtZXRob2Q6IHN0cmluZyxcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgb3B0aW9uczogeyBib2R5PzogdW5rbm93bjsgcXVlcnk/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCB1bmRlZmluZWQ+IH0gPSB7fVxuICApOiBQcm9taXNlPFQ+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdEVudmVsb3BlPFQ+KG1ldGhvZCwgcGF0aCwgb3B0aW9ucyk7XG4gICAgaWYgKHJlc3BvbnNlLmRhdGEgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiQVBJIHJldHVybmVkIG5vIGRhdGFcIik7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH1cblxuICBhc3luYyB1cGxvYWRGaWxlKGZpbGU6IEZpbGUpOiBQcm9taXNlPHsgYXNzZXRJZDogc3RyaW5nOyBzdGF0dXM6IHN0cmluZyB9PiB7XG4gICAgY29uc3QgbWltZVR5cGUgPSBpbmZlck1pbWVUeXBlKGZpbGUpO1xuICAgIGNvbnN0IGluaXQgPSBhd2FpdCB0aGlzLnJlcXVlc3REYXRhPFVwbG9hZEluaXRSZXNwb25zZT4oXCJQT1NUXCIsIFwiL2Fzc2V0cy91cGxvYWRcIiwge1xuICAgICAgYm9keTogeyBmaWxlTmFtZTogZmlsZS5uYW1lLCBtaW1lVHlwZSwgZmlsZVNpemU6IGZpbGUuc2l6ZSB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB1cGxvYWRSZXNwb25zZSA9IGF3YWl0IGZldGNoKGluaXQuc2FzVXBsb2FkVXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICBoZWFkZXJzOiB7IFwieC1tcy1ibG9iLXR5cGVcIjogXCJCbG9ja0Jsb2JcIiwgXCJDb250ZW50LVR5cGVcIjogbWltZVR5cGUgfSxcbiAgICAgIGJvZHk6IGZpbGVcbiAgICB9KTtcblxuICAgIGlmICghdXBsb2FkUmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmxvYiB1cGxvYWQgZmFpbGVkOiAke3VwbG9hZFJlc3BvbnNlLnN0YXR1c30gJHt1cGxvYWRSZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlcXVlc3REYXRhPHsgYXNzZXRJZDogc3RyaW5nOyBzdGF0dXM6IHN0cmluZyB9PihcIlBPU1RcIiwgXCIvYXNzZXRzL3VwbG9hZC9jb25maXJtXCIsIHtcbiAgICAgIGJvZHk6IHsgYXNzZXRJZDogaW5pdC5hc3NldElkIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGxpc3RBc3NldHMocGFyYW1zOiB7XG4gICAgY2F0ZWdvcnk/OiBzdHJpbmc7XG4gICAgc3RhdHVzPzogc3RyaW5nO1xuICAgIGxpbWl0PzogbnVtYmVyO1xuICAgIGNvbnRpbnVhdGlvblRva2VuPzogc3RyaW5nO1xuICB9KTogUHJvbWlzZTx7IGl0ZW1zOiBBc3NldFtdOyBjb250aW51YXRpb25Ub2tlbj86IHN0cmluZyB9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3RFbnZlbG9wZTxBc3NldFtdPihcIkdFVFwiLCBcIi9hc3NldHNcIiwgeyBxdWVyeTogcGFyYW1zIH0pO1xuICAgIHJldHVybiB7IGl0ZW1zOiByZXNwb25zZS5kYXRhID8/IFtdLCBjb250aW51YXRpb25Ub2tlbjogcmVzcG9uc2UucGFnaW5hdGlvbj8uY29udGludWF0aW9uVG9rZW4gfTtcbiAgfVxuXG4gIGFzeW5jIGdldEFzc2V0KGlkOiBzdHJpbmcpOiBQcm9taXNlPEFzc2V0PiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdERhdGE8QXNzZXQ+KFwiR0VUXCIsIGAvYXNzZXRzLyR7aWR9YCk7XG4gIH1cblxuICBhc3luYyBnZXRBc3NldFZpZXdVcmwoaWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3REYXRhPHsgdmlld1VybDogc3RyaW5nIH0+KFwiR0VUXCIsIGAvYXNzZXRzLyR7aWR9L3ZpZXctdXJsYCk7XG4gICAgaWYgKCFyZXNwb25zZS52aWV3VXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWaWV3IFVSTCB1bmF2YWlsYWJsZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLnZpZXdVcmw7XG4gIH1cblxuICBhc3luYyBkZWxldGVBc3NldChpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5yZXF1ZXN0RW52ZWxvcGUoXCJERUxFVEVcIiwgYC9hc3NldHMvJHtpZH1gKTtcbiAgfVxuXG4gIGFzeW5jIGxpc3RDYXRlZ29yaWVzKCk6IFByb21pc2U8Q2F0ZWdvcnlbXT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3REYXRhPENhdGVnb3J5W10+KFwiR0VUXCIsIFwiL2NhdGVnb3JpZXNcIik7XG4gIH1cblxuICBhc3luYyBjcmVhdGVDYXRlZ29yeShuYW1lOiBzdHJpbmcpOiBQcm9taXNlPENhdGVnb3J5PiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdERhdGE8Q2F0ZWdvcnk+KFwiUE9TVFwiLCBcIi9jYXRlZ29yaWVzXCIsIHsgYm9keTogeyBuYW1lLCBmaWVsZFByaW9yaXRpZXM6IFtdIH0gfSk7XG4gIH1cblxuICBhc3luYyB1cGRhdGVDYXRlZ29yeShpZDogc3RyaW5nLCBwYXlsb2FkOiB7IG5hbWU/OiBzdHJpbmc7IGZpZWxkUHJpb3JpdGllcz86IHN0cmluZ1tdIH0pOiBQcm9taXNlPENhdGVnb3J5PiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdERhdGE8Q2F0ZWdvcnk+KFwiUEFUQ0hcIiwgYC9jYXRlZ29yaWVzLyR7aWR9YCwgeyBib2R5OiBwYXlsb2FkIH0pO1xuICB9XG5cbiAgYXN5bmMgZGVsZXRlQ2F0ZWdvcnkoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMucmVxdWVzdEVudmVsb3BlKFwiREVMRVRFXCIsIGAvY2F0ZWdvcmllcy8ke2lkfWApO1xuICB9XG5cbiAgYXN5bmMgc2VhcmNoKHF1ZXJ5OiBzdHJpbmcsIGxpbWl0ID0gMjApOiBQcm9taXNlPFNlYXJjaFJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdERhdGE8U2VhcmNoUmVzcG9uc2U+KFwiR0VUXCIsIFwiL3NlYXJjaFwiLCB7IHF1ZXJ5OiB7IHE6IHF1ZXJ5LCBsaW1pdCB9IH0pO1xuICB9XG5cbiAgYXN5bmMgZ2V0U2V0dGluZ3MoKTogUHJvbWlzZTxVc2VyU2V0dGluZ3M+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RGF0YTxVc2VyU2V0dGluZ3M+KFwiR0VUXCIsIFwiL3NldHRpbmdzXCIpO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlU2V0dGluZ3MocGF5bG9hZDogeyBleHRyYWN0aW9uTW9kZT86IFwiYWlcIiB8IFwib2NyXCI7IGFpUHJvdmlkZXI/OiBcIm9wZW5haVwiIHwgXCJhbnRocm9waWNcIiB8IFwiZ29vZ2xlXCI7IGFwaUtleT86IHN0cmluZyB9KTogUHJvbWlzZTxVc2VyU2V0dGluZ3M+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RGF0YTxVc2VyU2V0dGluZ3M+KFwiUEFUQ0hcIiwgXCIvc2V0dGluZ3NcIiwgeyBib2R5OiBwYXlsb2FkIH0pO1xuICB9XG59XG4iXSwibmFtZXMiOlsiYXBpQmFzZVVybCIsImluZmVyTWltZVR5cGUiLCJmaWxlIiwidHlwZSIsImluY2x1ZGVzIiwibm9ybWFsaXplZCIsIm5hbWUiLCJ0b0xvd2VyQ2FzZSIsImVuZHNXaXRoIiwiRXJyb3IiLCJXZWJBcGlDbGllbnQiLCJjcmVhdGVVcmwiLCJwYXRoIiwicXVlcnkiLCJiYXNlIiwicmVzb2x2ZWRCYXNlIiwic3RhcnRzV2l0aCIsIndpbmRvdyIsImxvY2F0aW9uIiwib3JpZ2luIiwidXJsIiwiVVJMIiwicmVwbGFjZSIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsInVuZGVmaW5lZCIsInNlYXJjaFBhcmFtcyIsInNldCIsIlN0cmluZyIsInRvU3RyaW5nIiwicmVxdWVzdEVudmVsb3BlIiwibWV0aG9kIiwib3B0aW9ucyIsImhlYWRlcnMiLCJBY2NlcHQiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInJlc3BvbnNlIiwiZmV0Y2giLCJjcmVkZW50aWFscyIsImpzb24iLCJjYXRjaCIsIm9rIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJlcnJvciIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJyZXF1ZXN0RGF0YSIsImRhdGEiLCJ1cGxvYWRGaWxlIiwibWltZVR5cGUiLCJpbml0IiwiZmlsZU5hbWUiLCJmaWxlU2l6ZSIsInNpemUiLCJ1cGxvYWRSZXNwb25zZSIsInNhc1VwbG9hZFVybCIsImFzc2V0SWQiLCJsaXN0QXNzZXRzIiwicGFyYW1zIiwiaXRlbXMiLCJjb250aW51YXRpb25Ub2tlbiIsInBhZ2luYXRpb24iLCJnZXRBc3NldCIsImlkIiwiZ2V0QXNzZXRWaWV3VXJsIiwidmlld1VybCIsImRlbGV0ZUFzc2V0IiwibGlzdENhdGVnb3JpZXMiLCJjcmVhdGVDYXRlZ29yeSIsImZpZWxkUHJpb3JpdGllcyIsInVwZGF0ZUNhdGVnb3J5IiwicGF5bG9hZCIsImRlbGV0ZUNhdGVnb3J5Iiwic2VhcmNoIiwibGltaXQiLCJxIiwiZ2V0U2V0dGluZ3MiLCJ1cGRhdGVTZXR0aW5ncyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api-client.ts\n"));

/***/ })

});