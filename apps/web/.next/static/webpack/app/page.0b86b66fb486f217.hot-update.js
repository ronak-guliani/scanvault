"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/api-client.ts":
/*!*******************************!*\
  !*** ./src/lib/api-client.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebApiClient: function() { return /* binding */ WebApiClient; }\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"(app-pages-browser)/./src/lib/config.ts\");\n\nfunction inferMimeType(file) {\n    if (file.type && [\n        \"image/png\",\n        \"image/jpeg\",\n        \"image/webp\",\n        \"application/pdf\"\n    ].includes(file.type)) {\n        return file.type;\n    }\n    const normalized = file.name.toLowerCase();\n    if (normalized.endsWith(\".png\")) return \"image/png\";\n    if (normalized.endsWith(\".jpg\") || normalized.endsWith(\".jpeg\")) return \"image/jpeg\";\n    if (normalized.endsWith(\".webp\")) return \"image/webp\";\n    if (normalized.endsWith(\".pdf\")) return \"application/pdf\";\n    throw new Error(\"Unsupported file type. Use png, jpg, webp, or pdf.\");\n}\nclass WebApiClient {\n    createUrl(path, query) {\n        const base = _config__WEBPACK_IMPORTED_MODULE_0__.apiBaseUrl.endsWith(\"/\") ? _config__WEBPACK_IMPORTED_MODULE_0__.apiBaseUrl : \"\".concat(_config__WEBPACK_IMPORTED_MODULE_0__.apiBaseUrl, \"/\");\n        const resolvedBase = base.startsWith(\"http://\") || base.startsWith(\"https://\") ? base : \"\".concat(window.location.origin).concat(base.startsWith(\"/\") ? \"\" : \"/\").concat(base);\n        const url = new URL(path.replace(/^\\//, \"\"), resolvedBase);\n        if (query) {\n            for (const [key, value] of Object.entries(query)){\n                if (value !== undefined && value !== \"\") {\n                    url.searchParams.set(key, String(value));\n                }\n            }\n        }\n        return url.toString();\n    }\n    async requestEnvelope(method, path) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const headers = {\n            Accept: \"application/json\"\n        };\n        let body;\n        if (options.body !== undefined) {\n            headers[\"Content-Type\"] = \"application/json\";\n            body = JSON.stringify(options.body);\n        }\n        // Cookies are sent automatically; the proxy injects the Bearer token\n        const response = await fetch(this.createUrl(path, options.query), {\n            method,\n            headers,\n            body,\n            credentials: \"same-origin\"\n        });\n        const json = await response.json().catch(()=>({}));\n        if (!response.ok || json.success === false) {\n            var _json_error;\n            var _json_error_message;\n            const message = (_json_error_message = (_json_error = json.error) === null || _json_error === void 0 ? void 0 : _json_error.message) !== null && _json_error_message !== void 0 ? _json_error_message : \"\".concat(response.status, \" \").concat(response.statusText);\n            throw new Error(message);\n        }\n        return json;\n    }\n    async requestData(method, path) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const response = await this.requestEnvelope(method, path, options);\n        if (response.data === undefined) throw new Error(\"API returned no data\");\n        return response.data;\n    }\n    async uploadFile(file) {\n        const mimeType = inferMimeType(file);\n        const init = await this.requestData(\"POST\", \"/assets/upload\", {\n            body: {\n                fileName: file.name,\n                mimeType,\n                fileSize: file.size\n            }\n        });\n        const uploadResponse = await fetch(init.sasUploadUrl, {\n            method: \"PUT\",\n            headers: {\n                \"x-ms-blob-type\": \"BlockBlob\",\n                \"Content-Type\": mimeType\n            },\n            body: file\n        });\n        if (!uploadResponse.ok) {\n            throw new Error(\"Blob upload failed: \".concat(uploadResponse.status, \" \").concat(uploadResponse.statusText));\n        }\n        return this.requestData(\"POST\", \"/assets/upload/confirm\", {\n            body: {\n                assetId: init.assetId\n            }\n        });\n    }\n    async listAssets(params) {\n        var _response_pagination;\n        const response = await this.requestEnvelope(\"GET\", \"/assets\", {\n            query: params\n        });\n        var _response_data;\n        return {\n            items: (_response_data = response.data) !== null && _response_data !== void 0 ? _response_data : [],\n            continuationToken: (_response_pagination = response.pagination) === null || _response_pagination === void 0 ? void 0 : _response_pagination.continuationToken\n        };\n    }\n    async getAsset(id) {\n        return this.requestData(\"GET\", \"/assets/\".concat(id));\n    }\n    async getAssetViewUrl(id) {\n        const response = await this.requestData(\"GET\", \"/assets/\".concat(id, \"/view-url\"));\n        if (!response.viewUrl) {\n            throw new Error(\"View URL unavailable\");\n        }\n        return response.viewUrl;\n    }\n    async deleteAsset(id) {\n        await this.requestEnvelope(\"DELETE\", \"/assets/\".concat(id));\n    }\n    async moveAssetToCategory(assetId, categoryId) {\n        return this.requestData(\"PATCH\", \"/assets/\".concat(assetId, \"/category\"), {\n            body: {\n                categoryId\n            }\n        });\n    }\n    async listCategories() {\n        return this.requestData(\"GET\", \"/categories\");\n    }\n    async createCategory(name) {\n        return this.requestData(\"POST\", \"/categories\", {\n            body: {\n                name,\n                fieldPriorities: []\n            }\n        });\n    }\n    async updateCategory(id, payload) {\n        return this.requestData(\"PATCH\", \"/categories/\".concat(id), {\n            body: payload\n        });\n    }\n    async deleteCategory(id) {\n        await this.requestEnvelope(\"DELETE\", \"/categories/\".concat(id));\n    }\n    async search(query) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20;\n        return this.requestData(\"GET\", \"/search\", {\n            query: {\n                q: query,\n                limit\n            }\n        });\n    }\n    async getSettings() {\n        return this.requestData(\"GET\", \"/settings\");\n    }\n    async updateSettings(payload) {\n        return this.requestData(\"PATCH\", \"/settings\", {\n            body: payload\n        });\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXBpLWNsaWVudC50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUNzQztBQW1CdEMsU0FBU0MsY0FBY0MsSUFBVTtJQUMvQixJQUFJQSxLQUFLQyxJQUFJLElBQUk7UUFBQztRQUFhO1FBQWM7UUFBYztLQUFrQixDQUFDQyxRQUFRLENBQUNGLEtBQUtDLElBQUksR0FBRztRQUNqRyxPQUFPRCxLQUFLQyxJQUFJO0lBQ2xCO0lBRUEsTUFBTUUsYUFBYUgsS0FBS0ksSUFBSSxDQUFDQyxXQUFXO0lBQ3hDLElBQUlGLFdBQVdHLFFBQVEsQ0FBQyxTQUFTLE9BQU87SUFDeEMsSUFBSUgsV0FBV0csUUFBUSxDQUFDLFdBQVdILFdBQVdHLFFBQVEsQ0FBQyxVQUFVLE9BQU87SUFDeEUsSUFBSUgsV0FBV0csUUFBUSxDQUFDLFVBQVUsT0FBTztJQUN6QyxJQUFJSCxXQUFXRyxRQUFRLENBQUMsU0FBUyxPQUFPO0lBQ3hDLE1BQU0sSUFBSUMsTUFBTTtBQUNsQjtBQUVPLE1BQU1DO0lBQ0hDLFVBQVVDLElBQVksRUFBRUMsS0FBbUQsRUFBVTtRQUMzRixNQUFNQyxPQUFPZCwrQ0FBVUEsQ0FBQ1EsUUFBUSxDQUFDLE9BQU9SLCtDQUFVQSxHQUFHLEdBQWMsT0FBWEEsK0NBQVVBLEVBQUM7UUFDbkUsTUFBTWUsZUFDSkQsS0FBS0UsVUFBVSxDQUFDLGNBQWNGLEtBQUtFLFVBQVUsQ0FBQyxjQUMxQ0YsT0FDQSxHQUE0QkEsT0FBekJHLE9BQU9DLFFBQVEsQ0FBQ0MsTUFBTSxFQUFxQ0wsT0FBbENBLEtBQUtFLFVBQVUsQ0FBQyxPQUFPLEtBQUssS0FBVyxPQUFMRjtRQUNwRSxNQUFNTSxNQUFNLElBQUlDLElBQUlULEtBQUtVLE9BQU8sQ0FBQyxPQUFPLEtBQUtQO1FBQzdDLElBQUlGLE9BQU87WUFDVCxLQUFLLE1BQU0sQ0FBQ1UsS0FBS0MsTUFBTSxJQUFJQyxPQUFPQyxPQUFPLENBQUNiLE9BQVE7Z0JBQ2hELElBQUlXLFVB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RSxLQUFhLEVBQXVDO1lBQXJDb0UsUUFBQUEsaUVBQVE7UUFDbEMsT0FBTyxJQUFJLENBQUM5QixXQUFXLENBQWlCLE9BQU8sV0FBVztZQUFFdEMsT0FBTztnQkFBRXFFLEdBQUdyRTtnQkFBT29FO1lBQU07UUFBRTtJQUN6RjtJQUVBLE1BQU1FLGNBQXFDO1FBQ3pDLE9BQU8sSUFBSSxDQUFDaEMsV0FBVyxDQUFlLE9BQU87SUFDL0M7SUFFQSxNQUFNaUMsZUFBZU4sT0FBMkcsRUFBeUI7UUFDdkosT0FBTyxJQUFJLENBQUMzQixXQUFXLENBQWUsU0FBUyxhQUFhO1lBQUVkLE1BQU15QztRQUFRO0lBQzlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9hcGktY2xpZW50LnRzP2FjMTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBBc3NldCwgQ2F0ZWdvcnksIFVzZXJTZXR0aW5ncyB9IGZyb20gXCJAc2NhbnZhdWx0L3NoYXJlZFwiO1xuaW1wb3J0IHsgYXBpQmFzZVVybCB9IGZyb20gXCIuL2NvbmZpZ1wiO1xuXG5pbnRlcmZhY2UgQXBpRW52ZWxvcGU8VD4ge1xuICBzdWNjZXNzOiBib29sZWFuO1xuICBkYXRhPzogVDtcbiAgZXJyb3I/OiB7IGNvZGU6IHN0cmluZzsgbWVzc2FnZTogc3RyaW5nIH07XG4gIHBhZ2luYXRpb24/OiB7IGNvbnRpbnVhdGlvblRva2VuPzogc3RyaW5nIH07XG59XG5cbmludGVyZmFjZSBVcGxvYWRJbml0UmVzcG9uc2Uge1xuICBhc3NldElkOiBzdHJpbmc7XG4gIHNhc1VwbG9hZFVybDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgU2VhcmNoUmVzcG9uc2Uge1xuICBxdWVyeTogdW5rbm93bjtcbiAgaXRlbXM6IEFzc2V0W107XG59XG5cbmZ1bmN0aW9uIGluZmVyTWltZVR5cGUoZmlsZTogRmlsZSk6IHN0cmluZyB7XG4gIGlmIChmaWxlLnR5cGUgJiYgW1wiaW1hZ2UvcG5nXCIsIFwiaW1hZ2UvanBlZ1wiLCBcImltYWdlL3dlYnBcIiwgXCJhcHBsaWNhdGlvbi9wZGZcIl0uaW5jbHVkZXMoZmlsZS50eXBlKSkge1xuICAgIHJldHVybiBmaWxlLnR5cGU7XG4gIH1cblxuICBjb25zdCBub3JtYWxpemVkID0gZmlsZS5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChub3JtYWxpemVkLmVuZHNXaXRoKFwiLnBuZ1wiKSkgcmV0dXJuIFwiaW1hZ2UvcG5nXCI7XG4gIGlmIChub3JtYWxpemVkLmVuZHNXaXRoKFwiLmpwZ1wiKSB8fCBub3JtYWxpemVkLmVuZHNXaXRoKFwiLmpwZWdcIikpIHJldHVybiBcImltYWdlL2pwZWdcIjtcbiAgaWYgKG5vcm1hbGl6ZWQuZW5kc1dpdGgoXCIud2VicFwiKSkgcmV0dXJuIFwiaW1hZ2Uvd2VicFwiO1xuICBpZiAobm9ybWFsaXplZC5lbmRzV2l0aChcIi5wZGZcIikpIHJldHVybiBcImFwcGxpY2F0aW9uL3BkZlwiO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBmaWxlIHR5cGUuIFVzZSBwbmcsIGpwZywgd2VicCwgb3IgcGRmLlwiKTtcbn1cblxuZXhwb3J0IGNsYXNzIFdlYkFwaUNsaWVudCB7XG4gIHByaXZhdGUgY3JlYXRlVXJsKHBhdGg6IHN0cmluZywgcXVlcnk/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCB1bmRlZmluZWQ+KTogc3RyaW5nIHtcbiAgICBjb25zdCBiYXNlID0gYXBpQmFzZVVybC5lbmRzV2l0aChcIi9cIikgPyBhcGlCYXNlVXJsIDogYCR7YXBpQmFzZVVybH0vYDtcbiAgICBjb25zdCByZXNvbHZlZEJhc2UgPVxuICAgICAgYmFzZS5zdGFydHNXaXRoKFwiaHR0cDovL1wiKSB8fCBiYXNlLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKVxuICAgICAgICA/IGJhc2VcbiAgICAgICAgOiBgJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufSR7YmFzZS5zdGFydHNXaXRoKFwiL1wiKSA/IFwiXCIgOiBcIi9cIn0ke2Jhc2V9YDtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhdGgucmVwbGFjZSgvXlxcLy8sIFwiXCIpLCByZXNvbHZlZEJhc2UpO1xuICAgIGlmIChxdWVyeSkge1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocXVlcnkpKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBcIlwiKSB7XG4gICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCBTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJlcXVlc3RFbnZlbG9wZTxUPihcbiAgICBtZXRob2Q6IHN0cmluZyxcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgb3B0aW9uczogeyBib2R5PzogdW5rbm93bjsgcXVlcnk/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCB1bmRlZmluZWQ+IH0gPSB7fVxuICApOiBQcm9taXNlPEFwaUVudmVsb3BlPFQ+PiB7XG4gICAgY29uc3QgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHsgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIiB9O1xuXG4gICAgbGV0IGJvZHk6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBpZiAob3B0aW9ucy5ib2R5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmJvZHkpO1xuICAgIH1cblxuICAgIC8vIENvb2tpZXMgYXJlIHNlbnQgYXV0b21hdGljYWxseTsgdGhlIHByb3h5IGluamVjdHMgdGhlIEJlYXJlciB0b2tlblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy5jcmVhdGVVcmwocGF0aCwgb3B0aW9ucy5xdWVyeSksIHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5LFxuICAgICAgY3JlZGVudGlhbHM6IFwic2FtZS1vcmlnaW5cIixcbiAgICB9KTtcblxuICAgIGNvbnN0IGpzb24gPSAoYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpKSBhcyBBcGlFbnZlbG9wZTxUPjtcblxuICAgIGlmICghcmVzcG9uc2Uub2sgfHwganNvbi5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGpzb24uZXJyb3I/Lm1lc3NhZ2UgPz8gYCR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmVxdWVzdERhdGE8VD4oXG4gICAgbWV0aG9kOiBzdHJpbmcsXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIG9wdGlvbnM6IHsgYm9keT86IHVua25vd247IHF1ZXJ5PzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgdW5kZWZpbmVkPiB9ID0ge31cbiAgKTogUHJvbWlzZTxUPiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3RFbnZlbG9wZTxUPihtZXRob2QsIHBhdGgsIG9wdGlvbnMpO1xuICAgIGlmIChyZXNwb25zZS5kYXRhID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcIkFQSSByZXR1cm5lZCBubyBkYXRhXCIpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9XG5cbiAgYXN5bmMgdXBsb2FkRmlsZShmaWxlOiBGaWxlKTogUHJvbWlzZTx7IGFzc2V0SWQ6IHN0cmluZzsgc3RhdHVzOiBzdHJpbmcgfT4ge1xuICAgIGNvbnN0IG1pbWVUeXBlID0gaW5mZXJNaW1lVHlwZShmaWxlKTtcbiAgICBjb25zdCBpbml0ID0gYXdhaXQgdGhpcy5yZXF1ZXN0RGF0YTxVcGxvYWRJbml0UmVzcG9uc2U+KFwiUE9TVFwiLCBcIi9hc3NldHMvdXBsb2FkXCIsIHtcbiAgICAgIGJvZHk6IHsgZmlsZU5hbWU6IGZpbGUubmFtZSwgbWltZVR5cGUsIGZpbGVTaXplOiBmaWxlLnNpemUgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgdXBsb2FkUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChpbml0LnNhc1VwbG9hZFVybCwge1xuICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgaGVhZGVyczogeyBcIngtbXMtYmxvYi10eXBlXCI6IFwiQmxvY2tCbG9iXCIsIFwiQ29udGVudC1UeXBlXCI6IG1pbWVUeXBlIH0sXG4gICAgICBib2R5OiBmaWxlXG4gICAgfSk7XG5cbiAgICBpZiAoIXVwbG9hZFJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJsb2IgdXBsb2FkIGZhaWxlZDogJHt1cGxvYWRSZXNwb25zZS5zdGF0dXN9ICR7dXBsb2FkUmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RGF0YTx7IGFzc2V0SWQ6IHN0cmluZzsgc3RhdHVzOiBzdHJpbmcgfT4oXCJQT1NUXCIsIFwiL2Fzc2V0cy91cGxvYWQvY29uZmlybVwiLCB7XG4gICAgICBib2R5OiB7IGFzc2V0SWQ6IGluaXQuYXNzZXRJZCB9XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBsaXN0QXNzZXRzKHBhcmFtczoge1xuICAgIGNhdGVnb3J5Pzogc3RyaW5nO1xuICAgIHN0YXR1cz86IHN0cmluZztcbiAgICBsaW1pdD86IG51bWJlcjtcbiAgICBjb250aW51YXRpb25Ub2tlbj86IHN0cmluZztcbiAgfSk6IFByb21pc2U8eyBpdGVtczogQXNzZXRbXTsgY29udGludWF0aW9uVG9rZW4/OiBzdHJpbmcgfT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5yZXF1ZXN0RW52ZWxvcGU8QXNzZXRbXT4oXCJHRVRcIiwgXCIvYXNzZXRzXCIsIHsgcXVlcnk6IHBhcmFtcyB9KTtcbiAgICByZXR1cm4geyBpdGVtczogcmVzcG9uc2UuZGF0YSA/PyBbXSwgY29udGludWF0aW9uVG9rZW46IHJlc3BvbnNlLnBhZ2luYXRpb24/LmNvbnRpbnVhdGlvblRva2VuIH07XG4gIH1cblxuICBhc3luYyBnZXRBc3NldChpZDogc3RyaW5nKTogUHJvbWlzZTxBc3NldD4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3REYXRhPEFzc2V0PihcIkdFVFwiLCBgL2Fzc2V0cy8ke2lkfWApO1xuICB9XG5cbiAgYXN5bmMgZ2V0QXNzZXRWaWV3VXJsKGlkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5yZXF1ZXN0RGF0YTx7IHZpZXdVcmw6IHN0cmluZyB9PihcIkdFVFwiLCBgL2Fzc2V0cy8ke2lkfS92aWV3LXVybGApO1xuICAgIGlmICghcmVzcG9uc2Uudmlld1VybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmlldyBVUkwgdW5hdmFpbGFibGVcIik7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS52aWV3VXJsO1xuICB9XG5cbiAgYXN5bmMgZGVsZXRlQXNzZXQoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMucmVxdWVzdEVudmVsb3BlKFwiREVMRVRFXCIsIGAvYXNzZXRzLyR7aWR9YCk7XG4gIH1cblxuICBhc3luYyBtb3ZlQXNzZXRUb0NhdGVnb3J5KGFzc2V0SWQ6IHN0cmluZywgY2F0ZWdvcnlJZDogc3RyaW5nKTogUHJvbWlzZTxBc3NldD4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3REYXRhPEFzc2V0PihcIlBBVENIXCIsIGAvYXNzZXRzLyR7YXNzZXRJZH0vY2F0ZWdvcnlgLCB7XG4gICAgICBib2R5OiB7IGNhdGVnb3J5SWQgfVxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgbGlzdENhdGVnb3JpZXMoKTogUHJvbWlzZTxDYXRlZ29yeVtdPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdERhdGE8Q2F0ZWdvcnlbXT4oXCJHRVRcIiwgXCIvY2F0ZWdvcmllc1wiKTtcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZUNhdGVnb3J5KG5hbWU6IHN0cmluZyk6IFByb21pc2U8Q2F0ZWdvcnk+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RGF0YTxDYXRlZ29yeT4oXCJQT1NUXCIsIFwiL2NhdGVnb3JpZXNcIiwgeyBib2R5OiB7IG5hbWUsIGZpZWxkUHJpb3JpdGllczogW10gfSB9KTtcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZUNhdGVnb3J5KGlkOiBzdHJpbmcsIHBheWxvYWQ6IHsgbmFtZT86IHN0cmluZzsgZmllbGRQcmlvcml0aWVzPzogc3RyaW5nW10gfSk6IFByb21pc2U8Q2F0ZWdvcnk+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RGF0YTxDYXRlZ29yeT4oXCJQQVRDSFwiLCBgL2NhdGVnb3JpZXMvJHtpZH1gLCB7IGJvZHk6IHBheWxvYWQgfSk7XG4gIH1cblxuICBhc3luYyBkZWxldGVDYXRlZ29yeShpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5yZXF1ZXN0RW52ZWxvcGUoXCJERUxFVEVcIiwgYC9jYXRlZ29yaWVzLyR7aWR9YCk7XG4gIH1cblxuICBhc3luYyBzZWFyY2gocXVlcnk6IHN0cmluZywgbGltaXQgPSAyMCk6IFByb21pc2U8U2VhcmNoUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RGF0YTxTZWFyY2hSZXNwb25zZT4oXCJHRVRcIiwgXCIvc2VhcmNoXCIsIHsgcXVlcnk6IHsgcTogcXVlcnksIGxpbWl0IH0gfSk7XG4gIH1cblxuICBhc3luYyBnZXRTZXR0aW5ncygpOiBQcm9taXNlPFVzZXJTZXR0aW5ncz4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3REYXRhPFVzZXJTZXR0aW5ncz4oXCJHRVRcIiwgXCIvc2V0dGluZ3NcIik7XG4gIH1cblxuICBhc3luYyB1cGRhdGVTZXR0aW5ncyhwYXlsb2FkOiB7IGV4dHJhY3Rpb25Nb2RlPzogXCJhaVwiIHwgXCJvY3JcIjsgYWlQcm92aWRlcj86IFwib3BlbmFpXCIgfCBcImFudGhyb3BpY1wiIHwgXCJnb29nbGVcIjsgYXBpS2V5Pzogc3RyaW5nIH0pOiBQcm9taXNlPFVzZXJTZXR0aW5ncz4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3REYXRhPFVzZXJTZXR0aW5ncz4oXCJQQVRDSFwiLCBcIi9zZXR0aW5nc1wiLCB7IGJvZHk6IHBheWxvYWQgfSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJhcGlCYXNlVXJsIiwiaW5mZXJNaW1lVHlwZSIsImZpbGUiLCJ0eXBlIiwiaW5jbHVkZXMiLCJub3JtYWxpemVkIiwibmFtZSIsInRvTG93ZXJDYXNlIiwiZW5kc1dpdGgiLCJFcnJvciIsIldlYkFwaUNsaWVudCIsImNyZWF0ZVVybCIsInBhdGgiLCJxdWVyeSIsImJhc2UiLCJyZXNvbHZlZEJhc2UiLCJzdGFydHNXaXRoIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJ1cmwiLCJVUkwiLCJyZXBsYWNlIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwidW5kZWZpbmVkIiwic2VhcmNoUGFyYW1zIiwic2V0IiwiU3RyaW5nIiwidG9TdHJpbmciLCJyZXF1ZXN0RW52ZWxvcGUiLCJtZXRob2QiLCJvcHRpb25zIiwiaGVhZGVycyIsIkFjY2VwdCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwicmVzcG9uc2UiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwianNvbiIsImNhdGNoIiwib2siLCJzdWNjZXNzIiwibWVzc2FnZSIsImVycm9yIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsInJlcXVlc3REYXRhIiwiZGF0YSIsInVwbG9hZEZpbGUiLCJtaW1lVHlwZSIsImluaXQiLCJmaWxlTmFtZSIsImZpbGVTaXplIiwic2l6ZSIsInVwbG9hZFJlc3BvbnNlIiwic2FzVXBsb2FkVXJsIiwiYXNzZXRJZCIsImxpc3RBc3NldHMiLCJwYXJhbXMiLCJpdGVtcyIsImNvbnRpbnVhdGlvblRva2VuIiwicGFnaW5hdGlvbiIsImdldEFzc2V0IiwiaWQiLCJnZXRBc3NldFZpZXdVcmwiLCJ2aWV3VXJsIiwiZGVsZXRlQXNzZXQiLCJtb3ZlQXNzZXRUb0NhdGVnb3J5IiwiY2F0ZWdvcnlJZCIsImxpc3RDYXRlZ29yaWVzIiwiY3JlYXRlQ2F0ZWdvcnkiLCJmaWVsZFByaW9yaXRpZXMiLCJ1cGRhdGVDYXRlZ29yeSIsInBheWxvYWQiLCJkZWxldGVDYXRlZ29yeSIsInNlYXJjaCIsImxpbWl0IiwicSIsImdldFNldHRpbmdzIiwidXBkYXRlU2V0dGluZ3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api-client.ts\n"));

/***/ })

});