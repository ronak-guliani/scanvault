"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rou3";
exports.ids = ["vendor-chunks/rou3"];
exports.modules = {

/***/ "(rsc)/../../node_modules/rou3/dist/index.mjs":
/*!**********************************************!*\
  !*** ../../node_modules/rou3/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NullProtoObj: () => (/* binding */ NullProtoObj),\n/* harmony export */   addRoute: () => (/* binding */ addRoute),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   findAllRoutes: () => (/* binding */ findAllRoutes),\n/* harmony export */   findRoute: () => (/* binding */ findRoute),\n/* harmony export */   removeRoute: () => (/* binding */ removeRoute),\n/* harmony export */   routeToRegExp: () => (/* binding */ routeToRegExp)\n/* harmony export */ });\nconst NullProtoObj = /* @__PURE__ */ (() => {\n\tconst e = function() {};\n\treturn e.prototype = Object.create(null), Object.freeze(e.prototype), e;\n})();\n\n/**\n* Create a new router context.\n*/\nfunction createRouter() {\n\treturn {\n\t\troot: { key: \"\" },\n\t\tstatic: new NullProtoObj()\n\t};\n}\n\nfunction splitPath(path) {\n\tconst [_, ...s] = path.split(\"/\");\n\treturn s[s.length - 1] === \"\" ? s.slice(0, -1) : s;\n}\nfunction getMatchParams(segments, paramsMap) {\n\tconst params = new NullProtoObj();\n\tfor (const [index, name] of paramsMap) {\n\t\tconst segment = index < 0 ? segments.slice(-(index + 1)).join(\"/\") : segments[index];\n\t\tif (typeof name === \"string\") params[name] = segment;\n\t\telse {\n\t\t\tconst match = segment.match(name);\n\t\t\tif (match) for (const key in match.groups) params[key] = match.groups[key];\n\t\t}\n\t}\n\treturn params;\n}\n\n/**\n* Add a route to the router context.\n*/\nfunction addRoute(ctx, method = \"\", path, data) {\n\tmethod = method.toUpperCase();\n\tif (path.charCodeAt(0) !== 47) path = `/${path}`;\n\tpath = path.replace(/\\\\:/g, \"%3A\");\n\tconst segments = splitPath(path);\n\tlet node = ctx.root;\n\tlet _unnamedParamIndex = 0;\n\tconst paramsMap = [];\n\tconst paramsRegexp = [];\n\tfor (let i = 0; i < segments.length; i++) {\n\t\tlet segment = segments[i];\n\t\tif (segment.startsWith(\"**\")) {\n\t\t\tif (!node.wildcard) node.wildcard = { key: \"**\" };\n\t\t\tnode = node.wildcard;\n\t\t\tparamsMap.push([\n\t\t\t\t-(i + 1),\n\t\t\t\tsegment.split(\":\")[1] || \"_\",\n\t\t\t\tsegment.length === 2\n\t\t\t]);\n\t\t\tbreak;\n\t\t}\n\t\tif (segment === \"*\" || segment.includes(\":\")) {\n\t\t\tif (!node.param) node.param = { key: \"*\" };\n\t\t\tnode = node.param;\n\t\t\tif (segment === \"*\") paramsMap.push([\n\t\t\t\ti,\n\t\t\t\t`_${_unnamedParamIndex++}`,\n\t\t\t\ttrue\n\t\t\t]);\n\t\t\telse if (segment.includes(\":\", 1)) {\n\t\t\t\tconst regexp = getParamRegexp(segment);\n\t\t\t\tparamsRegexp[i] = regexp;\n\t\t\t\tnode.hasRegexParam = true;\n\t\t\t\tparamsMap.push([\n\t\t\t\t\ti,\n\t\t\t\t\tregexp,\n\t\t\t\t\tfalse\n\t\t\t\t]);\n\t\t\t} else paramsMap.push([\n\t\t\t\ti,\n\t\t\t\tsegment.slice(1),\n\t\t\t\tfalse\n\t\t\t]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (segment === \"\\\\*\") segment = segments[i] = \"*\";\n\t\telse if (segment === \"\\\\*\\\\*\") segment = segments[i] = \"**\";\n\t\tconst child = node.static?.[segment];\n\t\tif (child) node = child;\n\t\telse {\n\t\t\tconst staticNode = { key: segment };\n\t\t\tif (!node.static) node.static = new NullProtoObj();\n\t\t\tnode.static[segment] = staticNode;\n\t\t\tnode = staticNode;\n\t\t}\n\t}\n\tconst hasParams = paramsMap.length > 0;\n\tif (!node.methods) node.methods = new NullProtoObj();\n\tnode.methods[method] ??= [];\n\tnode.methods[method].push({\n\t\tdata: data || null,\n\t\tparamsRegexp,\n\t\tparamsMap: hasParams ? paramsMap : void 0\n\t});\n\tif (!hasParams) ctx.static[\"/\" + segments.join(\"/\")] = node;\n}\nfunction getParamRegexp(segment) {\n\tconst regex = segment.replace(/:(\\w+)/g, (_, id) => `(?<${id}>[^/]+)`).replace(/\\./g, \"\\\\.\");\n\treturn /* @__PURE__ */ new RegExp(`^${regex}$`);\n}\n\n/**\n* Find a route by path.\n*/\nfunction findRoute(ctx, method = \"\", path, opts) {\n\tif (path.charCodeAt(path.length - 1) === 47) path = path.slice(0, -1);\n\tconst staticNode = ctx.static[path];\n\tif (staticNode && staticNode.methods) {\n\t\tconst staticMatch = staticNode.methods[method] || staticNode.methods[\"\"];\n\t\tif (staticMatch !== void 0) return staticMatch[0];\n\t}\n\tconst segments = splitPath(path);\n\tconst match = _lookupTree(ctx, ctx.root, method, segments, 0)?.[0];\n\tif (match === void 0) return;\n\tif (opts?.params === false) return match;\n\treturn {\n\t\tdata: match.data,\n\t\tparams: match.paramsMap ? getMatchParams(segments, match.paramsMap) : void 0\n\t};\n}\nfunction _lookupTree(ctx, node, method, segments, index) {\n\tif (index === segments.length) {\n\t\tif (node.methods) {\n\t\t\tconst match = node.methods[method] || node.methods[\"\"];\n\t\t\tif (match) return match;\n\t\t}\n\t\tif (node.param && node.param.methods) {\n\t\t\tconst match = node.param.methods[method] || node.param.methods[\"\"];\n\t\t\tif (match) {\n\t\t\t\tconst pMap = match[0].paramsMap;\n\t\t\t\tif (pMap?.[pMap?.length - 1]?.[2]) return match;\n\t\t\t}\n\t\t}\n\t\tif (node.wildcard && node.wildcard.methods) {\n\t\t\tconst match = node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n\t\t\tif (match) {\n\t\t\t\tconst pMap = match[0].paramsMap;\n\t\t\t\tif (pMap?.[pMap?.length - 1]?.[2]) return match;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tconst segment = segments[index];\n\tif (node.static) {\n\t\tconst staticChild = node.static[segment];\n\t\tif (staticChild) {\n\t\t\tconst match = _lookupTree(ctx, staticChild, method, segments, index + 1);\n\t\t\tif (match) return match;\n\t\t}\n\t}\n\tif (node.param) {\n\t\tconst match = _lookupTree(ctx, node.param, method, segments, index + 1);\n\t\tif (match) {\n\t\t\tif (node.param.hasRegexParam) {\n\t\t\t\tconst exactMatch = match.find((m) => m.paramsRegexp[index]?.test(segment)) || match.find((m) => !m.paramsRegexp[index]);\n\t\t\t\treturn exactMatch ? [exactMatch] : void 0;\n\t\t\t}\n\t\t\treturn match;\n\t\t}\n\t}\n\tif (node.wildcard && node.wildcard.methods) return node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n}\n\n/**\n* Remove a route from the router context.\n*/\nfunction removeRoute(ctx, method, path) {\n\tconst segments = splitPath(path);\n\treturn _remove(ctx.root, method || \"\", segments, 0);\n}\nfunction _remove(node, method, segments, index) {\n\tif (index === segments.length) {\n\t\tif (node.methods && method in node.methods) {\n\t\t\tdelete node.methods[method];\n\t\t\tif (Object.keys(node.methods).length === 0) node.methods = void 0;\n\t\t}\n\t\treturn;\n\t}\n\tconst segment = segments[index];\n\tif (segment === \"*\") {\n\t\tif (node.param) {\n\t\t\t_remove(node.param, method, segments, index + 1);\n\t\t\tif (_isEmptyNode(node.param)) node.param = void 0;\n\t\t}\n\t\treturn;\n\t}\n\tif (segment.startsWith(\"**\")) {\n\t\tif (node.wildcard) {\n\t\t\t_remove(node.wildcard, method, segments, index + 1);\n\t\t\tif (_isEmptyNode(node.wildcard)) node.wildcard = void 0;\n\t\t}\n\t\treturn;\n\t}\n\tconst childNode = node.static?.[segment];\n\tif (childNode) {\n\t\t_remove(childNode, method, segments, index + 1);\n\t\tif (_isEmptyNode(childNode)) {\n\t\t\tdelete node.static[segment];\n\t\t\tif (Object.keys(node.static).length === 0) node.static = void 0;\n\t\t}\n\t}\n}\nfunction _isEmptyNode(node) {\n\treturn node.methods === void 0 && node.static === void 0 && node.param === void 0 && node.wildcard === void 0;\n}\n\n/**\n* Find all route patterns that match the given path.\n*/\nfunction findAllRoutes(ctx, method = \"\", path, opts) {\n\tif (path.charCodeAt(path.length - 1) === 47) path = path.slice(0, -1);\n\tconst segments = splitPath(path);\n\tconst matches = _findAll(ctx, ctx.root, method, segments, 0);\n\tif (opts?.params === false) return matches;\n\treturn matches.map((m) => {\n\t\treturn {\n\t\t\tdata: m.data,\n\t\t\tparams: m.paramsMap ? getMatchParams(segments, m.paramsMap) : void 0\n\t\t};\n\t});\n}\nfunction _findAll(ctx, node, method, segments, index, matches = []) {\n\tconst segment = segments[index];\n\tif (node.wildcard && node.wildcard.methods) {\n\t\tconst match = node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n\t\tif (match) matches.push(...match);\n\t}\n\tif (node.param) {\n\t\t_findAll(ctx, node.param, method, segments, index + 1, matches);\n\t\tif (index === segments.length && node.param.methods) {\n\t\t\tconst match = node.param.methods[method] || node.param.methods[\"\"];\n\t\t\tif (match) {\n\t\t\t\tconst pMap = match[0].paramsMap;\n\t\t\t\tif (pMap?.[pMap?.length - 1]?.[2]) matches.push(...match);\n\t\t\t}\n\t\t}\n\t}\n\tconst staticChild = node.static?.[segment];\n\tif (staticChild) _findAll(ctx, staticChild, method, segments, index + 1, matches);\n\tif (index === segments.length && node.methods) {\n\t\tconst match = node.methods[method] || node.methods[\"\"];\n\t\tif (match) matches.push(...match);\n\t}\n\treturn matches;\n}\n\nfunction routeToRegExp(route = \"/\") {\n\tconst reSegments = [];\n\tlet idCtr = 0;\n\tfor (const segment of route.split(\"/\")) {\n\t\tif (!segment) continue;\n\t\tif (segment === \"*\") reSegments.push(`(?<_${idCtr++}>[^/]*)`);\n\t\telse if (segment.startsWith(\"**\")) reSegments.push(segment === \"**\" ? \"?(?<_>.*)\" : `?(?<${segment.slice(3)}>.+)`);\n\t\telse if (segment.includes(\":\")) reSegments.push(segment.replace(/:(\\w+)/g, (_, id) => `(?<${id}>[^/]+)`).replace(/\\./g, \"\\\\.\"));\n\t\telse reSegments.push(segment);\n\t}\n\treturn /* @__PURE__ */ new RegExp(`^/${reSegments.join(\"/\")}/?$`);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3JvdTMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxLQUFLO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxQkFBcUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsR0FBRztBQUM5RCx1Q0FBdUMsTUFBTTtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3RELDZGQUE2RixpQkFBaUI7QUFDOUcsOEZBQThGLEdBQUc7QUFDakc7QUFDQTtBQUNBLHdDQUF3QyxxQkFBcUI7QUFDN0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac2NhbnZhdWx0L3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvcm91My9kaXN0L2luZGV4Lm1qcz9kYmZjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE51bGxQcm90b09iaiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuXHRjb25zdCBlID0gZnVuY3Rpb24oKSB7fTtcblx0cmV0dXJuIGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgT2JqZWN0LmZyZWV6ZShlLnByb3RvdHlwZSksIGU7XG59KSgpO1xuXG4vKipcbiogQ3JlYXRlIGEgbmV3IHJvdXRlciBjb250ZXh0LlxuKi9cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlcigpIHtcblx0cmV0dXJuIHtcblx0XHRyb290OiB7IGtleTogXCJcIiB9LFxuXHRcdHN0YXRpYzogbmV3IE51bGxQcm90b09iaigpXG5cdH07XG59XG5cbmZ1bmN0aW9uIHNwbGl0UGF0aChwYXRoKSB7XG5cdGNvbnN0IFtfLCAuLi5zXSA9IHBhdGguc3BsaXQoXCIvXCIpO1xuXHRyZXR1cm4gc1tzLmxlbmd0aCAtIDFdID09PSBcIlwiID8gcy5zbGljZSgwLCAtMSkgOiBzO1xufVxuZnVuY3Rpb24gZ2V0TWF0Y2hQYXJhbXMoc2VnbWVudHMsIHBhcmFtc01hcCkge1xuXHRjb25zdCBwYXJhbXMgPSBuZXcgTnVsbFByb3RvT2JqKCk7XG5cdGZvciAoY29uc3QgW2luZGV4LCBuYW1lXSBvZiBwYXJhbXNNYXApIHtcblx0XHRjb25zdCBzZWdtZW50ID0gaW5kZXggPCAwID8gc2VnbWVudHMuc2xpY2UoLShpbmRleCArIDEpKS5qb2luKFwiL1wiKSA6IHNlZ21lbnRzW2luZGV4XTtcblx0XHRpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHBhcmFtc1tuYW1lXSA9IHNlZ21lbnQ7XG5cdFx0ZWxzZSB7XG5cdFx0XHRjb25zdCBtYXRjaCA9IHNlZ21lbnQubWF0Y2gobmFtZSk7XG5cdFx0XHRpZiAobWF0Y2gpIGZvciAoY29uc3Qga2V5IGluIG1hdGNoLmdyb3VwcykgcGFyYW1zW2tleV0gPSBtYXRjaC5ncm91cHNba2V5XTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHBhcmFtcztcbn1cblxuLyoqXG4qIEFkZCBhIHJvdXRlIHRvIHRoZSByb3V0ZXIgY29udGV4dC5cbiovXG5mdW5jdGlvbiBhZGRSb3V0ZShjdHgsIG1ldGhvZCA9IFwiXCIsIHBhdGgsIGRhdGEpIHtcblx0bWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG5cdGlmIChwYXRoLmNoYXJDb2RlQXQoMCkgIT09IDQ3KSBwYXRoID0gYC8ke3BhdGh9YDtcblx0cGF0aCA9IHBhdGgucmVwbGFjZSgvXFxcXDovZywgXCIlM0FcIik7XG5cdGNvbnN0IHNlZ21lbnRzID0gc3BsaXRQYXRoKHBhdGgpO1xuXHRsZXQgbm9kZSA9IGN0eC5yb290O1xuXHRsZXQgX3VubmFtZWRQYXJhbUluZGV4ID0gMDtcblx0Y29uc3QgcGFyYW1zTWFwID0gW107XG5cdGNvbnN0IHBhcmFtc1JlZ2V4cCA9IFtdO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0bGV0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRpZiAoc2VnbWVudC5zdGFydHNXaXRoKFwiKipcIikpIHtcblx0XHRcdGlmICghbm9kZS53aWxkY2FyZCkgbm9kZS53aWxkY2FyZCA9IHsga2V5OiBcIioqXCIgfTtcblx0XHRcdG5vZGUgPSBub2RlLndpbGRjYXJkO1xuXHRcdFx0cGFyYW1zTWFwLnB1c2goW1xuXHRcdFx0XHQtKGkgKyAxKSxcblx0XHRcdFx0c2VnbWVudC5zcGxpdChcIjpcIilbMV0gfHwgXCJfXCIsXG5cdFx0XHRcdHNlZ21lbnQubGVuZ3RoID09PSAyXG5cdFx0XHRdKTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRpZiAoc2VnbWVudCA9PT0gXCIqXCIgfHwgc2VnbWVudC5pbmNsdWRlcyhcIjpcIikpIHtcblx0XHRcdGlmICghbm9kZS5wYXJhbSkgbm9kZS5wYXJhbSA9IHsga2V5OiBcIipcIiB9O1xuXHRcdFx0bm9kZSA9IG5vZGUucGFyYW07XG5cdFx0XHRpZiAoc2VnbWVudCA9PT0gXCIqXCIpIHBhcmFtc01hcC5wdXNoKFtcblx0XHRcdFx0aSxcblx0XHRcdFx0YF8ke191bm5hbWVkUGFyYW1JbmRleCsrfWAsXG5cdFx0XHRcdHRydWVcblx0XHRcdF0pO1xuXHRcdFx0ZWxzZSBpZiAoc2VnbWVudC5pbmNsdWRlcyhcIjpcIiwgMSkpIHtcblx0XHRcdFx0Y29uc3QgcmVnZXhwID0gZ2V0UGFyYW1SZWdleHAoc2VnbWVudCk7XG5cdFx0XHRcdHBhcmFtc1JlZ2V4cFtpXSA9IHJlZ2V4cDtcblx0XHRcdFx0bm9kZS5oYXNSZWdleFBhcmFtID0gdHJ1ZTtcblx0XHRcdFx0cGFyYW1zTWFwLnB1c2goW1xuXHRcdFx0XHRcdGksXG5cdFx0XHRcdFx0cmVnZXhwLFxuXHRcdFx0XHRcdGZhbHNlXG5cdFx0XHRcdF0pO1xuXHRcdFx0fSBlbHNlIHBhcmFtc01hcC5wdXNoKFtcblx0XHRcdFx0aSxcblx0XHRcdFx0c2VnbWVudC5zbGljZSgxKSxcblx0XHRcdFx0ZmFsc2Vcblx0XHRcdF0pO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdGlmIChzZWdtZW50ID09PSBcIlxcXFwqXCIpIHNlZ21lbnQgPSBzZWdtZW50c1tpXSA9IFwiKlwiO1xuXHRcdGVsc2UgaWYgKHNlZ21lbnQgPT09IFwiXFxcXCpcXFxcKlwiKSBzZWdtZW50ID0gc2VnbWVudHNbaV0gPSBcIioqXCI7XG5cdFx0Y29uc3QgY2hpbGQgPSBub2RlLnN0YXRpYz8uW3NlZ21lbnRdO1xuXHRcdGlmIChjaGlsZCkgbm9kZSA9IGNoaWxkO1xuXHRcdGVsc2Uge1xuXHRcdFx0Y29uc3Qgc3RhdGljTm9kZSA9IHsga2V5OiBzZWdtZW50IH07XG5cdFx0XHRpZiAoIW5vZGUuc3RhdGljKSBub2RlLnN0YXRpYyA9IG5ldyBOdWxsUHJvdG9PYmooKTtcblx0XHRcdG5vZGUuc3RhdGljW3NlZ21lbnRdID0gc3RhdGljTm9kZTtcblx0XHRcdG5vZGUgPSBzdGF0aWNOb2RlO1xuXHRcdH1cblx0fVxuXHRjb25zdCBoYXNQYXJhbXMgPSBwYXJhbXNNYXAubGVuZ3RoID4gMDtcblx0aWYgKCFub2RlLm1ldGhvZHMpIG5vZGUubWV0aG9kcyA9IG5ldyBOdWxsUHJvdG9PYmooKTtcblx0bm9kZS5tZXRob2RzW21ldGhvZF0gPz89IFtdO1xuXHRub2RlLm1ldGhvZHNbbWV0aG9kXS5wdXNoKHtcblx0XHRkYXRhOiBkYXRhIHx8IG51bGwsXG5cdFx0cGFyYW1zUmVnZXhwLFxuXHRcdHBhcmFtc01hcDogaGFzUGFyYW1zID8gcGFyYW1zTWFwIDogdm9pZCAwXG5cdH0pO1xuXHRpZiAoIWhhc1BhcmFtcykgY3R4LnN0YXRpY1tcIi9cIiArIHNlZ21lbnRzLmpvaW4oXCIvXCIpXSA9IG5vZGU7XG59XG5mdW5jdGlvbiBnZXRQYXJhbVJlZ2V4cChzZWdtZW50KSB7XG5cdGNvbnN0IHJlZ2V4ID0gc2VnbWVudC5yZXBsYWNlKC86KFxcdyspL2csIChfLCBpZCkgPT4gYCg/PCR7aWR9PlteL10rKWApLnJlcGxhY2UoL1xcLi9nLCBcIlxcXFwuXCIpO1xuXHRyZXR1cm4gLyogQF9fUFVSRV9fICovIG5ldyBSZWdFeHAoYF4ke3JlZ2V4fSRgKTtcbn1cblxuLyoqXG4qIEZpbmQgYSByb3V0ZSBieSBwYXRoLlxuKi9cbmZ1bmN0aW9uIGZpbmRSb3V0ZShjdHgsIG1ldGhvZCA9IFwiXCIsIHBhdGgsIG9wdHMpIHtcblx0aWYgKHBhdGguY2hhckNvZGVBdChwYXRoLmxlbmd0aCAtIDEpID09PSA0NykgcGF0aCA9IHBhdGguc2xpY2UoMCwgLTEpO1xuXHRjb25zdCBzdGF0aWNOb2RlID0gY3R4LnN0YXRpY1twYXRoXTtcblx0aWYgKHN0YXRpY05vZGUgJiYgc3RhdGljTm9kZS5tZXRob2RzKSB7XG5cdFx0Y29uc3Qgc3RhdGljTWF0Y2ggPSBzdGF0aWNOb2RlLm1ldGhvZHNbbWV0aG9kXSB8fCBzdGF0aWNOb2RlLm1ldGhvZHNbXCJcIl07XG5cdFx0aWYgKHN0YXRpY01hdGNoICE9PSB2b2lkIDApIHJldHVybiBzdGF0aWNNYXRjaFswXTtcblx0fVxuXHRjb25zdCBzZWdtZW50cyA9IHNwbGl0UGF0aChwYXRoKTtcblx0Y29uc3QgbWF0Y2ggPSBfbG9va3VwVHJlZShjdHgsIGN0eC5yb290LCBtZXRob2QsIHNlZ21lbnRzLCAwKT8uWzBdO1xuXHRpZiAobWF0Y2ggPT09IHZvaWQgMCkgcmV0dXJuO1xuXHRpZiAob3B0cz8ucGFyYW1zID09PSBmYWxzZSkgcmV0dXJuIG1hdGNoO1xuXHRyZXR1cm4ge1xuXHRcdGRhdGE6IG1hdGNoLmRhdGEsXG5cdFx0cGFyYW1zOiBtYXRjaC5wYXJhbXNNYXAgPyBnZXRNYXRjaFBhcmFtcyhzZWdtZW50cywgbWF0Y2gucGFyYW1zTWFwKSA6IHZvaWQgMFxuXHR9O1xufVxuZnVuY3Rpb24gX2xvb2t1cFRyZWUoY3R4LCBub2RlLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCkge1xuXHRpZiAoaW5kZXggPT09IHNlZ21lbnRzLmxlbmd0aCkge1xuXHRcdGlmIChub2RlLm1ldGhvZHMpIHtcblx0XHRcdGNvbnN0IG1hdGNoID0gbm9kZS5tZXRob2RzW21ldGhvZF0gfHwgbm9kZS5tZXRob2RzW1wiXCJdO1xuXHRcdFx0aWYgKG1hdGNoKSByZXR1cm4gbWF0Y2g7XG5cdFx0fVxuXHRcdGlmIChub2RlLnBhcmFtICYmIG5vZGUucGFyYW0ubWV0aG9kcykge1xuXHRcdFx0Y29uc3QgbWF0Y2ggPSBub2RlLnBhcmFtLm1ldGhvZHNbbWV0aG9kXSB8fCBub2RlLnBhcmFtLm1ldGhvZHNbXCJcIl07XG5cdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0Y29uc3QgcE1hcCA9IG1hdGNoWzBdLnBhcmFtc01hcDtcblx0XHRcdFx0aWYgKHBNYXA/LltwTWFwPy5sZW5ndGggLSAxXT8uWzJdKSByZXR1cm4gbWF0Y2g7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChub2RlLndpbGRjYXJkICYmIG5vZGUud2lsZGNhcmQubWV0aG9kcykge1xuXHRcdFx0Y29uc3QgbWF0Y2ggPSBub2RlLndpbGRjYXJkLm1ldGhvZHNbbWV0aG9kXSB8fCBub2RlLndpbGRjYXJkLm1ldGhvZHNbXCJcIl07XG5cdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0Y29uc3QgcE1hcCA9IG1hdGNoWzBdLnBhcmFtc01hcDtcblx0XHRcdFx0aWYgKHBNYXA/LltwTWFwPy5sZW5ndGggLSAxXT8uWzJdKSByZXR1cm4gbWF0Y2g7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXHRjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXhdO1xuXHRpZiAobm9kZS5zdGF0aWMpIHtcblx0XHRjb25zdCBzdGF0aWNDaGlsZCA9IG5vZGUuc3RhdGljW3NlZ21lbnRdO1xuXHRcdGlmIChzdGF0aWNDaGlsZCkge1xuXHRcdFx0Y29uc3QgbWF0Y2ggPSBfbG9va3VwVHJlZShjdHgsIHN0YXRpY0NoaWxkLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCArIDEpO1xuXHRcdFx0aWYgKG1hdGNoKSByZXR1cm4gbWF0Y2g7XG5cdFx0fVxuXHR9XG5cdGlmIChub2RlLnBhcmFtKSB7XG5cdFx0Y29uc3QgbWF0Y2ggPSBfbG9va3VwVHJlZShjdHgsIG5vZGUucGFyYW0sIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4ICsgMSk7XG5cdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRpZiAobm9kZS5wYXJhbS5oYXNSZWdleFBhcmFtKSB7XG5cdFx0XHRcdGNvbnN0IGV4YWN0TWF0Y2ggPSBtYXRjaC5maW5kKChtKSA9PiBtLnBhcmFtc1JlZ2V4cFtpbmRleF0/LnRlc3Qoc2VnbWVudCkpIHx8IG1hdGNoLmZpbmQoKG0pID0+ICFtLnBhcmFtc1JlZ2V4cFtpbmRleF0pO1xuXHRcdFx0XHRyZXR1cm4gZXhhY3RNYXRjaCA/IFtleGFjdE1hdGNoXSA6IHZvaWQgMDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9XG5cdH1cblx0aWYgKG5vZGUud2lsZGNhcmQgJiYgbm9kZS53aWxkY2FyZC5tZXRob2RzKSByZXR1cm4gbm9kZS53aWxkY2FyZC5tZXRob2RzW21ldGhvZF0gfHwgbm9kZS53aWxkY2FyZC5tZXRob2RzW1wiXCJdO1xufVxuXG4vKipcbiogUmVtb3ZlIGEgcm91dGUgZnJvbSB0aGUgcm91dGVyIGNvbnRleHQuXG4qL1xuZnVuY3Rpb24gcmVtb3ZlUm91dGUoY3R4LCBtZXRob2QsIHBhdGgpIHtcblx0Y29uc3Qgc2VnbWVudHMgPSBzcGxpdFBhdGgocGF0aCk7XG5cdHJldHVybiBfcmVtb3ZlKGN0eC5yb290LCBtZXRob2QgfHwgXCJcIiwgc2VnbWVudHMsIDApO1xufVxuZnVuY3Rpb24gX3JlbW92ZShub2RlLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCkge1xuXHRpZiAoaW5kZXggPT09IHNlZ21lbnRzLmxlbmd0aCkge1xuXHRcdGlmIChub2RlLm1ldGhvZHMgJiYgbWV0aG9kIGluIG5vZGUubWV0aG9kcykge1xuXHRcdFx0ZGVsZXRlIG5vZGUubWV0aG9kc1ttZXRob2RdO1xuXHRcdFx0aWYgKE9iamVjdC5rZXlzKG5vZGUubWV0aG9kcykubGVuZ3RoID09PSAwKSBub2RlLm1ldGhvZHMgPSB2b2lkIDA7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXHRjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXhdO1xuXHRpZiAoc2VnbWVudCA9PT0gXCIqXCIpIHtcblx0XHRpZiAobm9kZS5wYXJhbSkge1xuXHRcdFx0X3JlbW92ZShub2RlLnBhcmFtLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCArIDEpO1xuXHRcdFx0aWYgKF9pc0VtcHR5Tm9kZShub2RlLnBhcmFtKSkgbm9kZS5wYXJhbSA9IHZvaWQgMDtcblx0XHR9XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGlmIChzZWdtZW50LnN0YXJ0c1dpdGgoXCIqKlwiKSkge1xuXHRcdGlmIChub2RlLndpbGRjYXJkKSB7XG5cdFx0XHRfcmVtb3ZlKG5vZGUud2lsZGNhcmQsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4ICsgMSk7XG5cdFx0XHRpZiAoX2lzRW1wdHlOb2RlKG5vZGUud2lsZGNhcmQpKSBub2RlLndpbGRjYXJkID0gdm9pZCAwO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblx0Y29uc3QgY2hpbGROb2RlID0gbm9kZS5zdGF0aWM/LltzZWdtZW50XTtcblx0aWYgKGNoaWxkTm9kZSkge1xuXHRcdF9yZW1vdmUoY2hpbGROb2RlLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCArIDEpO1xuXHRcdGlmIChfaXNFbXB0eU5vZGUoY2hpbGROb2RlKSkge1xuXHRcdFx0ZGVsZXRlIG5vZGUuc3RhdGljW3NlZ21lbnRdO1xuXHRcdFx0aWYgKE9iamVjdC5rZXlzKG5vZGUuc3RhdGljKS5sZW5ndGggPT09IDApIG5vZGUuc3RhdGljID0gdm9pZCAwO1xuXHRcdH1cblx0fVxufVxuZnVuY3Rpb24gX2lzRW1wdHlOb2RlKG5vZGUpIHtcblx0cmV0dXJuIG5vZGUubWV0aG9kcyA9PT0gdm9pZCAwICYmIG5vZGUuc3RhdGljID09PSB2b2lkIDAgJiYgbm9kZS5wYXJhbSA9PT0gdm9pZCAwICYmIG5vZGUud2lsZGNhcmQgPT09IHZvaWQgMDtcbn1cblxuLyoqXG4qIEZpbmQgYWxsIHJvdXRlIHBhdHRlcm5zIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHBhdGguXG4qL1xuZnVuY3Rpb24gZmluZEFsbFJvdXRlcyhjdHgsIG1ldGhvZCA9IFwiXCIsIHBhdGgsIG9wdHMpIHtcblx0aWYgKHBhdGguY2hhckNvZGVBdChwYXRoLmxlbmd0aCAtIDEpID09PSA0NykgcGF0aCA9IHBhdGguc2xpY2UoMCwgLTEpO1xuXHRjb25zdCBzZWdtZW50cyA9IHNwbGl0UGF0aChwYXRoKTtcblx0Y29uc3QgbWF0Y2hlcyA9IF9maW5kQWxsKGN0eCwgY3R4LnJvb3QsIG1ldGhvZCwgc2VnbWVudHMsIDApO1xuXHRpZiAob3B0cz8ucGFyYW1zID09PSBmYWxzZSkgcmV0dXJuIG1hdGNoZXM7XG5cdHJldHVybiBtYXRjaGVzLm1hcCgobSkgPT4ge1xuXHRcdHJldHVybiB7XG5cdFx0XHRkYXRhOiBtLmRhdGEsXG5cdFx0XHRwYXJhbXM6IG0ucGFyYW1zTWFwID8gZ2V0TWF0Y2hQYXJhbXMoc2VnbWVudHMsIG0ucGFyYW1zTWFwKSA6IHZvaWQgMFxuXHRcdH07XG5cdH0pO1xufVxuZnVuY3Rpb24gX2ZpbmRBbGwoY3R4LCBub2RlLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCwgbWF0Y2hlcyA9IFtdKSB7XG5cdGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpbmRleF07XG5cdGlmIChub2RlLndpbGRjYXJkICYmIG5vZGUud2lsZGNhcmQubWV0aG9kcykge1xuXHRcdGNvbnN0IG1hdGNoID0gbm9kZS53aWxkY2FyZC5tZXRob2RzW21ldGhvZF0gfHwgbm9kZS53aWxkY2FyZC5tZXRob2RzW1wiXCJdO1xuXHRcdGlmIChtYXRjaCkgbWF0Y2hlcy5wdXNoKC4uLm1hdGNoKTtcblx0fVxuXHRpZiAobm9kZS5wYXJhbSkge1xuXHRcdF9maW5kQWxsKGN0eCwgbm9kZS5wYXJhbSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxLCBtYXRjaGVzKTtcblx0XHRpZiAoaW5kZXggPT09IHNlZ21lbnRzLmxlbmd0aCAmJiBub2RlLnBhcmFtLm1ldGhvZHMpIHtcblx0XHRcdGNvbnN0IG1hdGNoID0gbm9kZS5wYXJhbS5tZXRob2RzW21ldGhvZF0gfHwgbm9kZS5wYXJhbS5tZXRob2RzW1wiXCJdO1xuXHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdGNvbnN0IHBNYXAgPSBtYXRjaFswXS5wYXJhbXNNYXA7XG5cdFx0XHRcdGlmIChwTWFwPy5bcE1hcD8ubGVuZ3RoIC0gMV0/LlsyXSkgbWF0Y2hlcy5wdXNoKC4uLm1hdGNoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Y29uc3Qgc3RhdGljQ2hpbGQgPSBub2RlLnN0YXRpYz8uW3NlZ21lbnRdO1xuXHRpZiAoc3RhdGljQ2hpbGQpIF9maW5kQWxsKGN0eCwgc3RhdGljQ2hpbGQsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4ICsgMSwgbWF0Y2hlcyk7XG5cdGlmIChpbmRleCA9PT0gc2VnbWVudHMubGVuZ3RoICYmIG5vZGUubWV0aG9kcykge1xuXHRcdGNvbnN0IG1hdGNoID0gbm9kZS5tZXRob2RzW21ldGhvZF0gfHwgbm9kZS5tZXRob2RzW1wiXCJdO1xuXHRcdGlmIChtYXRjaCkgbWF0Y2hlcy5wdXNoKC4uLm1hdGNoKTtcblx0fVxuXHRyZXR1cm4gbWF0Y2hlcztcbn1cblxuZnVuY3Rpb24gcm91dGVUb1JlZ0V4cChyb3V0ZSA9IFwiL1wiKSB7XG5cdGNvbnN0IHJlU2VnbWVudHMgPSBbXTtcblx0bGV0IGlkQ3RyID0gMDtcblx0Zm9yIChjb25zdCBzZWdtZW50IG9mIHJvdXRlLnNwbGl0KFwiL1wiKSkge1xuXHRcdGlmICghc2VnbWVudCkgY29udGludWU7XG5cdFx0aWYgKHNlZ21lbnQgPT09IFwiKlwiKSByZVNlZ21lbnRzLnB1c2goYCg/PF8ke2lkQ3RyKyt9PlteL10qKWApO1xuXHRcdGVsc2UgaWYgKHNlZ21lbnQuc3RhcnRzV2l0aChcIioqXCIpKSByZVNlZ21lbnRzLnB1c2goc2VnbWVudCA9PT0gXCIqKlwiID8gXCI/KD88Xz4uKilcIiA6IGA/KD88JHtzZWdtZW50LnNsaWNlKDMpfT4uKylgKTtcblx0XHRlbHNlIGlmIChzZWdtZW50LmluY2x1ZGVzKFwiOlwiKSkgcmVTZWdtZW50cy5wdXNoKHNlZ21lbnQucmVwbGFjZSgvOihcXHcrKS9nLCAoXywgaWQpID0+IGAoPzwke2lkfT5bXi9dKylgKS5yZXBsYWNlKC9cXC4vZywgXCJcXFxcLlwiKSk7XG5cdFx0ZWxzZSByZVNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG5cdH1cblx0cmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVnRXhwKGBeLyR7cmVTZWdtZW50cy5qb2luKFwiL1wiKX0vPyRgKTtcbn1cblxuZXhwb3J0IHsgTnVsbFByb3RvT2JqLCBhZGRSb3V0ZSwgY3JlYXRlUm91dGVyLCBmaW5kQWxsUm91dGVzLCBmaW5kUm91dGUsIHJlbW92ZVJvdXRlLCByb3V0ZVRvUmVnRXhwIH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/rou3/dist/index.mjs\n");

/***/ })

};
;